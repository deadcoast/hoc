# CAH 0.0.4 — Spec Gaps to Close (from the diagram)

## 1) Node taxonomy & lifecycle

* **Node set & roles:** `[CHO]`, `[ACT]`, `[DEC]`, `[{ABT}]`, `<!DEF!>` — define each node’s:

  * **Input/Output contract** (what it consumes/produces on each side and on the C-SP).
  * **State class** (transient vs committed).
  * **Determinism** (is outcome pure function of inputs?).
  * **Idempotency** (re-entering ABT/DEF with same payload).
* **Execution order semantics:** Triple-V implies concurrency; specify:

  * **Barrier points** (where synchronization is required before proceeding).
  * **Rollback/abort** conditions per node.

## 2) Continuity Spine (C-SP) topology

* **Column identities:** E-SC (left), M-SC (center), P-SC (right) — specify:

  * **Addressing scheme** (how flows reference a column).
  * **Routing rules** (which operators can cross between columns).
  * **Aggregation semantics** (when multiple flows converge in M-SC).

## 3) Flow operator grammar & algebra

* **Atomic tokens:** `v`, `<`, `>`, `+`, `-`, `│` (bar), box-drawing junctions.
* **Composites to define formally:** `<+`, `+>`, `-<`, `>-`, plain `<`, `>`, `v`.

  * **Directionality** (absolute vs relative to node/column).
  * **Precedence/associativity** (how composites bind).
  * **Entry/exit conditions** for C-SP (exactly when `<+`/`+>` are required).
  * **Closure rules** (what constitutes a “balanced” opener/closer pair in a span).
* **Validity constraints:** which composites are legal **inside** vs **outside** the C-SP.

## 4) “Triple V” and “vvvvv”

* **`v     v     v`** beneath `[CHO]`: declare as **simultaneous descent** markers; define:

  * **Clocking model** (lockstep vs event-driven).
  * **Side-effects** (does `v` carry payload or only direction?).
* **`vvvvv` inside the mid-box**: specify meaning (fan-in, multi-tick descent, buffering?), count-based semantics (why 5), and how it interacts with open/close operators adjacent to it.

## 5) Side semantics & MD-flo parity

* **[DD] dependence:** enumerate which constructs are side-dependent.
* **Parity definition:** formal criterion for “comparable, constructive effect”:

  * **Metric schema** (units, scales for `emo` vs `phl`).
  * **Acceptance thresholds** (tolerances, normalization).
  * **Failure class** when parity not met (reject vs degrade vs queue).

## 6) Essentials (`ent`) & variable system

* **Namespaces:** emotional `ev*` vs physical `pv*` — lock the **canonical prefixes** and allowed identifiers.
* **Typing:** scalar/vector/enum sets; units; bounds; monotonicity flags.
* **Scope & lifetime:** when variables are born, promoted to `ent`, persisted, or garbage-collected.
* **Aggregation:** how multiple `ev*`/`pv*` fold into a single `ent` (operator: sum, min, logic, weighted).

## 7) Brackets & punctuation semantics

* **`[{ABT}]`:** meaning of `[` `]` vs `{` `}` nesting around ABT.

  * Are these **mode flags** (e.g., `[ ]` = gate, `{ }` = contract/schema), or purely visual?
* **`<!DEF!>`:** define the `<! !>` punctuation as a **commit sink**:

  * **Commit protocol** (atomicity, versioning, conflict policy).
  * **Output form** (what exactly is serialized at DEF).
* **`(emo: … :phl)` band:** parenthetical lane with colon labels:

  * **Lane binding** rules (how left/right lanes map to E-SC/P-SC).
  * **Admissible contents** inside the band (lists, sets, typed pairs).

## 8) Box-drawing glyphs as syntax

* **`┌ ┐ └ ┘ ├ ┤ ┬ ┴ ┼ │ ─`**: declare which are **semantic** vs **decorative**.
* **Port semantics** where flows penetrate box borders (are borders firewalls, or just containers?).
* **Alignment rules** (must tokens align to cell boundaries to be valid?).

## 9) Open/Close span identity (“block flow”)

* Define a **span object** created by openers `<+`/`+>` and closed by `-<`/`>-`:

  * **Span ID** (how it’s tracked across the diagram).
  * **Payload binding** (which `ev*/pv*` and `ent` are attached).
  * **Re-entry** into C-SP (is nesting allowed? tail-closing order?).

## 10) ABT (Absolute) gate contract

* **Preconditions:** MD-flo parity, schema compliance, metrics thresholds.
* **Transform:** what ABT does (validate only vs normalize vs infer).
* **Postconditions:** what ABT guarantees about payload handed to DEF.
* **Rejection surface:** standardized error codes and where they are rendered in the diagram.

## 11) DEF (Define) commit semantics

* **Commit unit:** record, patch, or snapshot?
* **Immutability/versioning:** monotonic DEF log vs mutable last-write-wins.
* **Deterministic serialization:** canonical field order, stable hashing, newline/whitespace rules.

## 12) Serialization format (data interchange)

* **Token to data mapping:** how `[CHO]`, arrows, side-bands, and variables serialize.
* **Wire schema:** e.g., JSON/TOML/CBOR with:

  * **Type registry** for nodes/operators.
  * **Column addressing** (`E-SC`, `M-SC`, `P-SC`).
  * **Span structure** (open/close, payload, proofs of parity).
* **Round-trip fidelity:** rendering rules so serialized form regenerates the identical diagram.

## 13) Validation & static analysis

* **Grammar (EBNF) for the diagram language.**
* **Well-formedness checks:** matching open/close, legal adjacency, lane crossings.
* **Type checks:** side-correctness, metric units, bounds.
* **Lints:** forbidden aliases (e.g., `ATN`), ambiguous tokens, mixed spacing.

## 14) Timing & concurrency model

* **Event phases:** CHO→ACT→DEC→ABT→DEF ticks.
* **Hazards:** races across E-SC/P-SC, deadlocks at ABT.
* **Deterministic tie-breaks** for simultaneous closures.

## 15) Error model & observability

* **Error classes:** syntax, parity, type, gate, commit.
* **Where rendered:** inline markers adjacent to offending token vs out-of-band log.
* **Recoverability:** retry semantics, compensations, or quarantine.

## 16) Versioning & “absolute truth”

* **Spec version pinning:** `0.0.4` string in payloads.
* **Forward/back compat:** feature flags, deprecation fields.
* **Authoritative precedence:** explicit rule: **diagram > text**; encoded as a validation step.

## 17) Whitespace & layout constraints

* **Monospace requirements:** minimum cell grid, allowed line wraps.
* **Token spacing:** mandatory spaces around composite operators or not.
* **Line numbering (`|01│`):** whether it’s normative or documentation-only.

## 18) Notation registry

* **Reserved keywords:** `CHO, ACT, DEC, ABT, DEF, emo, phl, ent, ev*, pv*`.
* **Reserved symbols:** `v, <, >, +, -, (, ), {, }, [, ], !, :, │`.
* **Forbidden/legacy aliases:** explicitly disallow `ATN`, `var`, `vb2`, etc.

---

## Deliverables to write next (no examples—just spec text)

1. **Token inventory & EBNF grammar** (items §3, §7, §8, §17, §18).
2. **Operator algebra + validity table** (direction, entry/exit, closure) (§3).
3. **Node I/O contracts** and lifecycle (§1, §10, §11).
4. **MD-flo parity spec & metric schema** (§5).
5. **Span object definition** and balancing rules (§9).
6. **C-SP routing/aggregation rules** (§2).
7. **Serialization schema** with canonical ordering (§12).
8. **Validation suite** (well-formedness, type, parity, gate, commit) (§13).
9. **Error model & codes** (§15).
10. **Versioning & precedence rules** (§16).
