# NDM — Numeric Determinism Model (Normative)

## NDM.0 Scope

Defines numeric domains, comparison semantics, serialization format, rounding, and forbidden values for all CAH 0.0.4 computations (normalization, parity, metrics, commit objects).

## NDM.1 Domain & Encoding

* **Number type:** IEEE-754 **binary64** (double).
* **Forbidden values:** `NaN`, `+∞`, `−∞` MUST NOT appear in any serialized field; encountering them is a hard validation error (`E-NORM-A04` if from input; else `E-SYN-101`).
* **Canonical JSON encoding:**

  * Minimal decimal representation that round-trips to the same binary64 (RFC-8785 style): no leading `+`, no trailing zeroes, no unnecessary decimal point, scientific notation only when necessary.
  * `-0` serialized as `0`.
* **Arithmetic:** all arithmetic in evaluation (normalizers, parity aggregation) MUST be executed in binary64.

## NDM.2 Ordering & Comparison

* **Exact binary64 comparisons** with no epsilon, unless a field declares a tolerance policy.
* **Threshold checks:** `S_emo ≥ θ_emo` and `S_phl ≥ θ_phl` use exact comparisons.
* **Ratio check:** `min(S_emo,S_phl)/max(S_emo,S_phl) ≥ ρ` computed in binary64; division by zero is impossible under threshold preconditions; if encountered due to implementation error, emit `E-PARITY-502`.

## NDM.3 Rounding & Aggregation

* **Rounding mode:** **RoundTiesToEven** (IEEE default) for all intermediate and final steps.
* **Aggregation associativity:** implementations MUST aggregate in a stable order:

  * sort identifiers lexicographically ascending per side, then reduce left→right.
  * Any deviation is non-conformant and may cause digest divergence (`E-PREC-801` WARN at re-render check).

## NDM.4 Timestamps

* **Time base:** UTC.
* **Format:** RFC-3339 subset with `Z` suffix (`YYYY-MM-DDThh:mm:ss.sssZ`), millisecond precision minimum.
* **Clock skew:** apply IRS policy `max_clock_skew_seconds` where relevant (BVP).

## NDM.5 Serialization Constraints

* Numbers in `commit_object.metrics` and `payload_snapshot.*.scale_norm` MUST satisfy NDM.1–NDM.3 or the commit is invalid.
* Any numeric found outside these rules MUST trigger schema failure at serialization time (`E-SYN-101`).

---

## UR — Unit Registry (Schema & Conversion Rules)

## UR.0 Scope

A normative catalog of measurement units, metadata, and canonical conversions used by normalizers.

## UR.1 Concepts

* **UnitID**: canonical, stable identifier.
* **Quantity**: physical or logical dimension (e.g., time, mass, dimensionless).
* **System**: unit system label (`SI`, `nonSI`, `custom`).
* **Conversion**: mapping to a canonical **base unit** per quantity.

## UR.2 JSON Schema

```json
{
  "$id": "cah-0.0.4-unit-registry.schema.json",
  "title": "CAH Unit Registry",
  "type": "object",
  "properties": {
    "version": { "const": "0.0.4" },
    "quantities": {
      "type": "array",
      "items": {
        "type": "object",
        "properties": {
          "quantity_id": { "type": "string", "pattern": "^[a-z0-9._-]{2,64}$" },
          "base_unit": { "type": "string" },
          "units": {
            "type": "array",
            "items": { "$ref": "#/$defs/unit" }
          }
        },
        "required": ["quantity_id","base_unit","units"],
        "additionalProperties": false
      }
    }
  },
  "required": ["version","quantities"],
  "additionalProperties": false,
  "$defs": {
    "unit": {
      "type": "object",
      "properties": {
        "unit_id": { "type": "string", "pattern": "^[a-zA-Z0-9._/%-]{1,32}$" },
        "system": { "enum": ["SI","nonSI","custom"] },
        "symbol": { "type": "string" },
        "name": { "type": "string" },
        "to_base": {
          "type": "object",
          "properties": {
            "scale": { "type": "number" },      // multiplicative factor k
            "offset": { "type": "number", "default": 0 } // additive b; base = k*(x + b)
          },
          "required": ["scale"],
          "additionalProperties": false
        },
        "decimals_hint": { "type": "integer", "minimum": 0 }
      },
      "required": ["unit_id","system","to_base"],
      "additionalProperties": false
    }
  }
}
```

## UR.3 Conversion Semantics

* To convert raw value `x` in unit `u` to base: `x_base = scale_u * (x + offset_u)` using NDM arithmetic.
* **Round-trip determinism:** conversions MUST be applied prior to normalization; normalizers receive either:

  * values **already converted** to base unit, or
  * an explicit `unit` that matches the normalizer’s expected unit; mismatch ⇒ `E-NORM-A03`.
* **Dimensionless:** `unit_id="1"` (or `"dimensionless"`) MUST be represented with `scale=1`, `offset=0`.

## UR.4 Governance

* Each normalizer record (B.1) MUST reference a `unit` present in UR; otherwise `E-NORM-A03`.
* Registry evolution is append-only within a minor version; existing entries MUST remain immutable.

---

## PEG — Port Extractor Grammar (Machine Patterns)

## PEG.0 Scope

Defines the machine grammar for detecting structural **ports** in the diagram: `P_E1`, `P_P1`, `P_M1`, `P_A1`. Eliminates heuristic detection.

## PEG.1 Definitions

* **Segment**: left (`E_SC`), center (`M_SC`), right (`P_SC`) substrings partitioned by single `│`.
* **Token classes**: `ANGLE(<,>)`, `PLUS(+)`, `MINUS(-)`, `V(v)`, `LBRACK([)`, `RBRACK(])`, `LBRACE({)`, `RBRACE(})`, `LPAREN(()`, `RPAREN())`, `KW` (keywords), `SPACE`.
* **Fence tokens**: `TRIPLE-V` (`v SP v SP v`), `FIVE-V` (`vvvvv`).

## PEG.2 Port Patterns (per row)

* **P_E1 (left ingress/egress):**

  * **Ingress token pattern in `E_SC` immediately adjacent to center border:**

    * regex (monospace, no tabs): `v<\\+\\s*$` anchored to end of `E_SC` segment.
  * **Egress token pattern in `E_SC` immediately adjacent to center border:**

    * regex: `\\)>-\\s*$` anchored to end of `E_SC` segment.
* **P_P1 (right ingress/egress):**

  * **Ingress pattern in `P_SC` immediately adjacent to center border:**

    * regex: `^\\s*\\+>v`
  * **Egress pattern in `P_SC` immediately adjacent to center border:**

    * regex: `^\\s*-<\\(`
* **P_M1 (center lateral redistribution):**

  * **Pattern in `M_SC`:** single row contains `>\\s*v\\s*<` where the `v` is neither part of `TRIPLE-V` nor `FIVE-V`; enforce that the greater/less-than anchors are in `M_SC`.
* **P_A1 (ABT coupling, center only):**

  * **Pattern in `M_SC`:** `\\+<\\[\\{ABT\\}\\]>\\+` with exact keyword `ABT` and bracket/brace nesting.

## PEG.3 Disambiguation & Constraints

* Port detection is performed **after** whitespace normalization per T9, with preservation rules for fences.
* A row MAY host multiple port classes only if their patterns occur in their respective segments (e.g., `P_M1` in M_SC and `P_E1` in E_SC).
* If ambiguous matches occur due to overlapping tokens, prefer **longest match** per segment; ties → **leftmost** within the segment.

## PEG.4 Validation

* If an operator implies crossing without a detected port, raise `E-ROUTE-404`.
* If an `ABT` keyword is present without `P_A1` pattern intact, raise `E-PREC-802`.

---

## FEA — Features Manifest (Capabilities & Gates)

## FEA.0 Scope

Standardize optional features, discovery, and fail-closed gating for extensions beyond 0.0.4 core.

## FEA.1 Concepts

* **Feature ID**: stable string `feat.<namespace>.<name>`.
* **Gate**: boolean enablement toggle controlled by author or environment.
* **Capability**: implementation-advertised support for a feature.

## FEA.2 JSON Schema

```json
{
  "$id": "cah-0.0.4-features-manifest.schema.json",
  "title": "CAH Features Manifest",
  "type": "object",
  "properties": {
    "version": { "const": "0.0.4" },
    "features": {
      "type": "array",
      "items": {
        "type": "object",
        "properties": {
          "id": { "type": "string", "pattern": "^feat\\.[a-z0-9._-]+$" },
          "status": { "enum": ["required","optional","disabled"] },
          "vendor": { "type": "string", "pattern": "^[a-z0-9._-]{2,64}$" },
          "spec_ref": { "type": "string" },
          "since": { "type": "string", "pattern": "^0\\.[0-9]+\\.[0-9]+$" }
        },
        "required": ["id","status"],
        "additionalProperties": false
      }
    },
    "capabilities": {
      "type": "array",
      "items": {
        "type": "object",
        "properties": {
          "id": { "type": "string", "pattern": "^feat\\.[a-z0-9._-]+$" },
          "supported": { "type": "boolean" },
          "notes": { "type": "string" }
        },
        "required": ["id","supported"],
        "additionalProperties": false
      }
    },
    "policy": {
      "type": "object",
      "properties": {
        "fail_closed_on_unknown": { "type": "boolean", "const": true }
      },
      "additionalProperties": false
    }
  },
  "required": ["version","features","policy"],
  "additionalProperties": false
}
```

## FEA.3 Semantics

* Validators MUST parse the manifest, and if any feature has `status="required"` but is not listed as `supported=true` in capabilities, validation MUST fail early with `E-VERSION-901` (or a dedicated future code).
* Unknown features MUST cause a fail-closed decision (`policy.fail_closed_on_unknown=true`).
* Feature IDs under a vendor namespace MUST start with `feat.x-<vendor>.` to avoid collisions; the `x-` prefix is reserved for vendor extensions.

---
