# V1 — Validator Contract

## V1.1 Interface (pure functional)

* **Input:**

  * `diagram_text: string` (UTF-8)
  * `serialized_json: object|null` (optional; when present, must conform to T5)
  * `normalizer_catalog: object` (B.1 schema)
  * `options: object`

    * `strict: boolean` (default `true`)
    * `coerce_older_versions: boolean` (default `false`)
    * `emit_warnings: boolean` (default `true`)
* **Output:** `validation_report: object` (see V1.5)

## V1.2 Determinism

* Deterministic for identical inputs. No external time/random dependencies.

## V1.3 Phase graph (must execute in order)

1. **P-LEX** (lex/tokenize)
2. **P-PARSE** (AST + segment map)
3. **P-LAYOUT** (grid & borders)
4. **P-PORTS** (port detection P_E1/P_P1/P_M1/P_A1)
5. **P-ROUTE** (operator legality using the A.2 rule set)
6. **P-SPAN** (span creation/closure/nesting)
7. **P-SIDE** (variable side typing)
8. **P-BARRIER** (triple-v/five-v fences)
9. **P-NORM** (normalizer resolution & unit checks)
10. **P-PARITY** (θ/ρ checks)
11. **P-ABT** (gate contract: open-on-ingress, close-before-egress)
12. **P-DEF** (pre-commit invariants)
13. **P-VERSION** (spec/normalizer versions)
14. **P-PREC** (diagram supremacy vs serialized_json)
15. **P-REPORT** (aggregation & digest emission)

## V1.4 Location model

* **Diagram location:** `{row:int>=1, column: "E_SC|M_SC|P_SC", offset:int>=1}`
* **JSON location:** RFC-6901 JSON Pointer `#/path/to/field`
* **Dual-tagging:** every diagnostic MUST include **either** diagram location, **or** JSON location, **or both** when applicable.

## V1.5 Output structure

```json
{
  "version": "0.0.4",
  "diagram_digest": "<hex>",
  "passed": true,
  "errors": [ /* diagnostics */ ],
  "warnings": [ /* diagnostics */ ],
  "artifacts": {
    "ast": { /* opaque AST */ },
    "segments": [ /* segment grid with ports */ ],
    "spans": [ /* resolved spans with ids */ ],
    "nodes": [ /* node positions */ ],
    "serialized": { /* normalized JSON if provided or re-rendered */ }
  }
}
```

### Diagnostic record

```json
{
  "code": "E-XXXX-NNN",
  "severity": "ERROR|WARN",
  "message": "…",
  "diagram_loc": { "row": 0, "column": "M_SC", "offset": 0 },
  "json_ptr": "#/payloads/emo/evb",
  "phase": "P-…"
}
```

---

## V2 — Machine-Evaluable Rule Evaluation Order

For each phase, rules are evaluated in the listed sequence. “Stop-on-error” semantics apply per phase unless otherwise noted.

## P-LEX

1. Tokenize glyphs; flag `E-SYN-103` on `TAB`.
2. Unknown tokens → `E-SYN-101`.
3. Collect bracket/brace/paren counts for P-PARSE.

## P-PARSE

1. Build AST; unbalanced delimiters → `E-SYN-102`.
2. Check keywords per T10 → `E-SYN-104`.
3. Check operator formations per T1 → `E-SYN-105`.

## P-LAYOUT

1. Enforce three segments separated by single `│` per row; straddle → `E-LYT-201`.
2. Disallow frame glyphs within segments → `E-LYT-203`.
3. Normalize spacing (T9); non-canonical whitespace → WARN `E-LYT-2xx`.

## P-PORTS

1. Detect P_E1 / P_P1 / P_M1 / P_A1 by exact glyph patterns per T2.1.
2. Mark rows with ports; absence implies `port:"NONE"`.

## P-ROUTE

1. For each operator token, consult legality schema (A.2) with `(column, port)`.
2. Illegal lateral branch without port → `E-ROUTE-404`.
3. Crossing without open → `E-ROUTE-401`.
4. Egress without close → `E-ROUTE-402`.
5. Branch chaining without term → `E-ROUTE-403`.

## P-SPAN

1. Validate open/close stack per side → `E-SPAN-303`.
2. Unmatched open/close → `E-SPAN-301/302`.
3. Empty span → `E-SPAN-304`.
4. Illegal crossing path → `E-SPAN-306`.
5. Post-closure payload attach → `E-SPAN-305`.

## P-SIDE

1. `ev*` only in `E_SC`; violations → `E-SPAN-307`.
2. `pv*` only in `P_SC`; violations → `E-SPAN-307`.

## P-BARRIER

1. Enforce triple-v spacing (exact) → `E-BARRIER-601` on mismatch.
2. Enforce five-v fence behavior (ordering) → `E-BARRIER-601/602`.

## P-NORM

1. Resolve each `ev*`/`pv*` to normalizer → `E-PARITY-504` or `E-NORM-A02`.
2. Unit match → else `E-NORM-A03`.
3. Evaluate mapping monotonicity during registration (one-time) → `E-NORM-A05`.
4. Policy bounds check at usage → `E-NORM-A04`.

## P-PARITY

1. Aggregate `S_emo`, `S_phl` (T3.3).
2. Missing side → `E-PARITY-501`.
3. Threshold failure → `E-PARITY-502`.
4. Ratio failure → `E-PARITY-503`.

## P-ABT

1. Verify ingress to ABT occurs with open span → `E-ROUTE-401`.
2. Verify all spans closed before egress to DEF → `E-ROUTE-402`.
3. Non-admitted payload reaching ABT → escalate to `E-PARITY-*` already signaled.

## P-DEF

1. Forbid operators in DEF block → `E-DEF-703`.
2. Unclosed span at DEF → `E-DEF-701`.
3. Non-validated payload at DEF → `E-DEF-702`.
4. Multiple commits in one tick → `E-DEF-704`.

## P-VERSION

1. Check top-level `version` equals `"0.0.4"` → else `E-VERSION-901`.
2. Normalizer `normalizer_version.major == 0` → else `E-VERSION-902`.

## P-PREC

1. Compute `diagram_digest`.
2. If `serialized_json` present: re-render structure → digest′.
3. If digests differ: WARN `E-PREC-801`; adopt diagram path for remaining checks.

## P-REPORT

1. Aggregate diagnostics; set `passed = (no ERROR)`.
2. Emit canonical artifacts.

---

## V3 — Field-Level JSON Pointers (per check)

Below: **primary** JSON Pointer(s) to be attached for each diagnostic when `serialized_json` is present; otherwise, emit diagram location only. When multiple pointers apply, include all.

## Syntax

* `E-SYN-101` → `#/` (root; tokenization failure)
* `E-SYN-102` → `#/`
* `E-SYN-103` → `#/`
* `E-SYN-104` → offending keyword location if parsed → `#/nodes` or `#/spans/payload_refs`
* `E-SYN-105` → `#/spans` (operator formation affects span records)

## Layout

* `E-LYT-201` → none (diagram-only)
* `E-LYT-202` → `#/nodes` (port absence inferred from node/row mapping)
* `E-LYT-203` → none (diagram-only)

## Span

* `E-SPAN-301` → `#/spans/<i>` (span with unmatched open)
* `E-SPAN-302` → `#/spans/<i>`
* `E-SPAN-303` → `#/spans/<i>`
* `E-SPAN-304` → `#/spans/<i>`
* `E-SPAN-305` → `#/spans/<i>/payload_refs`
* `E-SPAN-306` → `#/spans/<i>`
* `E-SPAN-307` →

  * emotional side: `#/payloads/emo/<EV_ID>`
  * physical side: `#/payloads/phl/<PV_ID>`

## Routing

* `E-ROUTE-401` → `#/spans/<i>/open` (missing required opener for crossing)
* `E-ROUTE-402` → `#/spans/<i>/close` (missing required closer before egress)
* `E-ROUTE-403` → none (diagram-only operator chain)
* `E-ROUTE-404` → none (port missing; diagram-only)

## Parity

* `E-PARITY-501` → `#/payloads`
* `E-PARITY-502` →

  * emo threshold: `#/payloads/emo`
  * phl threshold: `#/payloads/phl`
* `E-PARITY-503` → `#/payloads`
* `E-PARITY-504` → pointer to unresolved var:

  * emo: `#/payloads/emo/<EV_ID>`
  * phl: `#/payloads/phl/<PV_ID>`
* `E-PARITY-505` → affected variable pointer as above

## Barrier

* `E-BARRIER-601` → none (diagram-only)
* `E-BARRIER-602` → `#/spans/<i>` (span mutated across barrier)

## Commit/DEF

* `E-DEF-701` → `#/spans`
* `E-DEF-702` → `#/payloads`
* `E-DEF-703` → none (diagram-only DEF block)
* `E-DEF-704` → `#/validation` (commit tick aggregation)

## Precedence/Diagram

* `E-PREC-801` → `#/diagram_digest` and `#/serialized`
* `E-PREC-802` → none (diagram-only; port absence)

## Versioning/Compatibility

* `E-VERSION-901` → `#/version`
* `E-VERSION-902` → offending normalizer:

  * `#/normalizer_catalog/catalog/<j>/normalizer_version`

## Normalization

* `E-NORM-A01` → `#/normalizer_catalog/catalog`
* `E-NORM-A02` → unresolved var pointer (same as E-PARITY-504)
* `E-NORM-A03` → offending variable pointer (same as E-PARITY-504)
* `E-NORM-A04` → offending variable pointer (same as E-PARITY-504)
* `E-NORM-A05` → offending normalizer pointer:

  * `#/normalizer_catalog/catalog/<j>`

---

## V4 — JSON Pointer Resolution Rules

1. Use **NFC-normalized** keys; pointer segments MUST be percent-decoded per RFC-6901.
2. `<i>` and `<j>` indices refer to creation order arrays (`spans`, `catalog`).
3. When a pointer targets a missing node due to diagram supremacy adoption, attach `json_ptr` to the **nearest parent** that exists and include a `note:"adopted_from_diagram"` field in the diagnostic (optional extension).

---

## V5 — Validator Compliance Levels

* **Level A (Authoring):** Run P-LEX→P-PORTS; tolerate WARNs in P-LAYOUT; do not require `serialized_json`.
* **Level B (Integration):** Full P-LEX→P-DEF; require `serialized_json`; FAIL on any ERROR up to P-DEF.
* **Level C (Commit):** Full P-LEX→P-PREC with `strict=true`; FAIL on any ERROR; WARNs recorded; `diagram_digest` required.

---
